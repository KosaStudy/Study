## [**OS] Race Condition**

race condition이란 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) ***읽거나 쓰는 동작***을 할 때,

- 읽거나 쓰는 동작?
    
    ### **Race Condition이 발생하는 경우**
    
    1. **커널 작업을 수행하는 중에 인터럽트 발생**
    
    - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
    
    - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.
    
    2. **프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때**
    
    - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
    
    - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함
    
    3. **멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때**
    
    - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
    
    - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법
    

 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황을 말한다. 이 때 경쟁하는 프로세스를 경쟁 프로세스라고 한다.

> 경쟁 프로세스의 경우 다음과 같은 세 가지 문제에 직면한다.
**Mutual exclusion, deadlock, starvation**이다.
> 

- **Mutual exclusion**
    
    Race condition을 막기 위해서는 **두 개 이상의 프로세스가 공용 데이터에 동시에 접근**을 하는 것을 막아야 한다. 즉, 한 프로세스가 공용 데이터를 사용하고 있으면 그 자원을 사용하지 못하도록 막거나, 다른 프로세스가 그 자원을 사용하지 못하도록 막으면 이 문제를 피할 수 있다. 이것을 상호 배제(mutual exclusion)라고 부른다.
    
- **Deadlock**
    
    그러나 위와 같은 상호 배제를 시행하면 추가적인 제어 문제가 발생한다. 하나는 교착상태 즉 여기서 말하는 Deadlock이다. 프로세스가 각자 프로그램을 실행하기 위해 두 자원 모두에 액세스 해야 한다고 가정할 때 프로세스는 두 자원 모두를 필요로 하므로 필요한 두 리소스를 사용하여 프로그램을 수행할 때까지 이미 소유한 리소스를 해제하지 않는다. 이러한 상황에서 두 프로세스는 교착 상태에 빠지게 되는 문제가 발생할 수 있다.
    
- **Starvation**
    
    이 제어 문제는 ‘기아 상태’라고도 한다. 이러한 문제는 프로세스들이 더 이상 진행을 하지 못하고 영구적으로 블록되어 있는 상태로, 시스템 자원에 대한 경쟁 도중에 발생할 수 있고 프로세스 간의 통신 과정에도 발생할 수 있는 문제이다. 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로는 아무것도 완료되지 못하는 상태가 되게 된다.
    

> 이를 예방하기 위한 방법 두 가지가 있다.
**Semaphore와 Mutex**이다.
> 

- Semaphore
    
    공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것이다
    
- Mutex
    
    공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 방법이다.